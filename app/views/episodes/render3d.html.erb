<% if JSON.parse(@episode.states).empty? %>
  <h1>Empty Data</h1>
<% else %>
  <canvas id="3d_episode_renderer" style="width:100%;height:100%;position:absolute;"></canvas>
  <div style="position:absolute;left:5px;top:5px;">
    <a href="/" class="btn btn-light">Home</a>
    <a href="/episodes/<%= @episode.id %>" class="btn btn-light">Episode</a>
  </div>
  <script>
    {
      let clock, canvas, renderer;
      let scene, camera, cameraControls, timelineController;

      const serializeTimelineData = function(states) {
        const dronePosition = {
          times: states.map(state => state.t / 1000.0),
          values: states.map(state => [state.x, state.y, state.z]).reduce((a, b) => a.concat(b)),
        };
        const droneQuaternion = {
          times: states.map(state => state.t / 1000.0),
          values: states.map(state => {
            const mat = new THREE.Matrix4();
            mat.makeRotationX(Math.radians(state.rx));
            mat.makeRotationY(Math.radians(state.ry));
            mat.makeRotationZ(Math.radians(state.rz));
            const quaternion = new THREE.Quaternion();
            quaternion.setFromRotationMatrix(mat);
            return [quaternion.x, quaternion.y, quaternion.z, quaternion.w]
          }).reduce((a, b) => a.concat(b)),
        };
        return {
          duration: states[states.length - 1].t / 1000.0,
          channels: {
            "drone.position": dronePosition,
            "drone.quaternion": droneQuaternion,
          }
        };
      };

      const init = function() {
        // Data
        const states = <%= raw @episode.states %>;
        const statesGeom = new THREE.Geometry();
        states.map(state => statesGeom.vertices.push(new THREE.Vector3(state.x, state.y, state.z)));

        // Time, Canvas, Renderer and its Viewport
        clock = new THREE.Clock();
        canvas = document.getElementById('3d_episode_renderer');
        renderer = new THREE.WebGLRenderer({canvas: canvas});
        canvas.width  = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        renderer.setViewport(0, 0, canvas.clientWidth, canvas.clientHeight);

        // ThreeJS Scene & Camera
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, canvas.clientWidth/canvas.clientHeight, 0.1, 1000);
        camera.position.set(2, 2, 2);
        camera.lookAt(new THREE.Vector3(1,1,0));

        // Camera Controls
        cameraControls = new THREE.TrackballControls(camera, renderer.domElement);
        cameraControls.target.set(0, 0, 0);

        // Grid & Axis
        const gridHelper = new THREE.GridHelper(5, 10);
        scene.add(gridHelper);
        const axisHelper = new THREE.AxisHelper(2);
        scene.add(axisHelper);

        // Trajectory
        const mLine = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1});
        const trajectory = new THREE.Line(statesGeom, mLine);
        scene.add(trajectory);

        // Points
        const mPoints = new THREE.PointsMaterial({ color: 0x888888, size: 3, sizeAttenuation: false });
        const points = new THREE.Points(statesGeom, mPoints);
        scene.add(points);

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 0.55);
        light.position.set(0, 0, 1);
        scene.add(light);

        // Drone Geometry for Animation
        const droneGeom = new THREE.Geometry();
        const droneMaterial = new THREE.MeshBasicMaterial({ color: 0x02c002, side: THREE.DoubleSide, vertexColors: THREE.FaceColors });
        droneGeom.vertices.push(
          new THREE.Vector3( 0.2, 0.0, 0.0),
          new THREE.Vector3(-0.1, 0.0, 0.1),
          new THREE.Vector3( 0.0, 0.0, 0.0),
          new THREE.Vector3(-0.1, 0.0,-0.1),
          new THREE.Vector3( 0.0,0.05, 0.0)
        );
        droneGeom.faces.push(
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0),
          new THREE.Face3(4, 0, 1),
          new THREE.Face3(4, 1, 2),
          new THREE.Face3(4, 2, 3),
          new THREE.Face3(4, 3, 0)
        );
        droneGeom.faces.map(face => face.color.setRGB(Math.random(), Math.random(), Math.random()));
        const drone = new THREE.Mesh(droneGeom, droneMaterial);
        drone.name = "drone";
        scene.add(drone);

        // Timeliner GUI
        const tracks = [
          {
            type: THREE.VectorKeyframeTrack,
            propertyPath: 'drone.position',
            initialValue: [ 0, 0, 0 ],
            interpolation: THREE.InterpolateSmooth
          },
          {
            type: THREE.QuaternionKeyframeTrack,
            propertyPath: 'drone.quaternion',
            initialValue: [ 0, 0, 0, 1 ],
            interpolation: THREE.InterpolateLinear

          }
        ];
        timelineController = new THREE.TimelinerController(scene, tracks, render);
        new Timeliner(timelineController);
        timelineController.deserialize(serializeTimelineData(states));
      };

      // Render Main Loop
      const render = function () {
        const delta = clock.getDelta();
        requestAnimationFrame(render);
        cameraControls.update(delta);
        renderer.render(scene, camera);
      };

      init();
      render();
    }
  </script>
  <style>
    .container.grid-960 {
      width: 100%;
      height: 100%;
      padding: 0;
    }
  </style>
<% end %>
